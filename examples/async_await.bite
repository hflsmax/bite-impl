eff Yield : ∀[].∀{}.() -> Unit_[];;
eff Fork : ∀[].∀{}.(∀[].∀{}.() -> Unit_[]) -> Unit_[];;

dcl partialResult := 0 in
dcl runq := ListInit 0 in
let suspend = fn [] {} (k : ∀[].∀{}.() -> Unit_[]) : Unit_[] is
    ListAppend runq k
end in
let run_next = fn [] {} () : Unit_[] is
    if ListEmpty runq then
        ()
    else
        let k = ListShift runq in
        resume k ()
end in
let spawn = fun spawnRec [] {} (f : ∀[].∀{lyield:Yield, lfork:Fork}.() -> Unit_[~lyield,~lfork]) : Unit_[] is
    handle lyield : Yield = fn [] {} () : Unit_[] is
        let r = ReifyResumer () in
        suspend r; run_next ()
    end in
        handle lfork : Fork = fn [] {} (forkf : ∀[].∀{lyield:Yield, lfork:Fork}.() -> Unit_[]) : Unit_[] is
            let r = ReifyResumer () in
            suspend r; spawnRec forkf
        end in
            f {lyield, lfork} ()
        end
    end
end in
    let job = fn [] {lyield:Yield, lfork:Fork} (yieldCounts : Int) : Unit_[~lyield,~lfork] is
        let jobRec = fn [] {lyield:Yield, lfork:Fork} (i : Int) : Unit_[~lyield,~lfork] is
            if 0 < i then
                raise lyield ();
                partialResult := !partialResult + 1;
                jobRec {lyield, lfork} (i - 1)
            else
                ()
        end in
            jobRec {lyield, lfork} yieldCounts
        end
    end in
        let start = fn [] {lyield:Yield, lfork:Fork} () : Unit_[~lyield,~lfork] is
            let startRec = fn [] {lyield:Yield, lfork:Fork} (i : Int) : Unit_[~lyield,~lfork] is
                if 0 < i then
                    raise lfork job;
                    startRec (i - 1)
                else
                    ()
            end in
                startRec 100100
            end
        end in
            spawn start;
            Print !partialResult
        end
    end
end
end
end
end