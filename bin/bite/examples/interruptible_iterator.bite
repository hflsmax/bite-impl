eff Replace : ∀[].∀{}.(int) -> int_[];;
eff Behead : ∀[].∀{}.() -> int_[];;
eff Yield : ∀[].∀{replace: Replace, behead: Behead}.(int) -> int_[~replace, ~behead];;

let iter = fun iterRec [] {yield: Yield, behead: Behead} (l: builtin) : int_[~yield, ~behead] is
    handle replace : Replace = fn [] {} (x : int) : int_[] is resume (IterSet l x; 0) end in
        raise yield {replace behead} (IterGet l)
    end;
    if IterHasNext l then
        0
    else
        handle localBehead : Behead = fn [] {} () : int_[] is resume (IterRemoveNext l; 0) end in
            iterRec {yield localBehead} (IterNext l)
        end
end in
    dcl list := ListInit 100100 in
        handle yield : Yield = fn [] {replace: Replace, behead: Behead} (x : int) : int_[~replace, ~behead] is
            resume (
                if x < 0 then
                    raise behead ()
                else
                    raise replace (x * 2)
            )
        end in
            handle behead : Behead = fn [] {} () : int_[] is resume (ListShift !list; 0) end in
                iter {yield behead} !list
            end
        end
    end
end